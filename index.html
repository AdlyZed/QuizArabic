<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Arabic Quiz</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link rel="icon" type="image/png" href="alif-icon.png">
  <link rel="manifest" href="manifest.json">
  <meta name="theme-color" content="#4a148c">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <style>
    :root {
      --bg: #0b0b0f;
      --card: #161625;
      --accent: #7a3cff;
      --accent-2: #9b6cff;
      --text: #e9e7ff;
      --muted: #cfc7ff;
      --green: #22c55e;
      --red: #ef4444;
    }
    * { box-sizing: border-box; }
    body {
      margin: 0;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      background: radial-gradient(1200px 600px at 10% 0%, rgba(122,60,255,0.12), transparent 60%), var(--bg);
      color: var(--text);
      display: flex; flex-direction: column; align-items: center;
      min-height: 100vh; padding: 20px;
    }
    h2 { text-align: center; color: var(--accent-2); margin: 10px 0 16px; }
    .screen { display: none; width: 100%; max-width: 640px; }
    .screen.active { display: block; }
    .card {
      background: linear-gradient(180deg, #1b1b30 0%, #121222 100%);
      border: 1px solid #26264a;
      border-radius: 16px;
      box-shadow: 0 10px 30px rgba(122,60,255,0.14);
      padding: 18px;
      margin-bottom: 16px;
    }
    .row { display: grid; grid-template-columns: 1fr; gap: 10px; }
    @media (min-width: 520px) { .row { grid-template-columns: 1fr 1fr; } }
    .btn {
      width: 100%; padding: 12px 14px; border: 1px solid #26264a; border-radius: 12px;
      background: #121222; color: var(--text); cursor: pointer;
      transition: transform 0.15s ease, background 0.25s ease, border-color 0.25s ease;
    }
    .btn:hover { transform: translateY(-2px); background: #191936; border-color: var(--accent); }
    .pill {
      display: inline-block; border: 1px solid #26264a; border-radius: 999px;
      padding: 6px 10px; background: #121222; color: var(--muted); font-size: 0.85rem;
    }
    .status { display: flex; justify-content: space-between; align-items: center; margin-top: 8px; }
    .prompt { text-align: center; color: var(--muted); }
    .arabic { font-size: 1.6rem; font-weight: 700; text-align: center; margin: 8px 0 6px; }
    .translit { font-size: 0.95rem; color: #cbbaff; text-align: center; margin-bottom: 12px; }
    .options { display: grid; grid-template-columns: 1fr; gap: 10px; }
    @media (min-width: 520px) { .options { grid-template-columns: 1fr 1fr; } }
    .option-card {
      background: #141427; border: 1px solid #24244a; border-radius: 12px;
      padding: 12px 14px; color: var(--text); cursor: pointer; user-select: none;
      transition: transform 0.15s ease, background 0.25s ease, border-color 0.25s ease, box-shadow 0.25s ease;
    }
    .option-card:hover { transform: translateY(-2px); background: #181836; box-shadow: 0 6px 16px rgba(122,60,255,0.18); }
    .option-card.correct {
      background: #0f2b1b; border-color: var(--green);
      box-shadow: 0 0 0 2px rgba(34,197,94,0.28) inset;
      animation: pulse 600ms ease;
    }
    .option-card.wrong {
      background: #2b0f0f; border-color: var(--red);
      box-shadow: 0 0 0 2px rgba(239,68,68,0.28) inset;
      animation: shake 380ms ease;
    }
    .options.disabled .option-card { pointer-events: none; opacity: 0.96; }
    .hint { text-align: center; color: var(--muted); font-size: 0.85rem; margin-top: 6px; }
    .loading { text-align: center; color: var(--muted); }
    .error { text-align: center; color: #ff9a9a; }

    @keyframes pulse { 0%{transform:scale(1)}50%{transform:scale(1.03)}100%{transform:scale(1)} }
    @keyframes shake {
      0%{transform:translateX(0)}20%{transform:translateX(-4px)}40%{transform:translateX(4px)}
      60%{transform:translateX(-3px)}80%{transform:translateX(3px)}100%{transform:translateX(0)}
    }
    .trademark {
     text-align: center;
     font-size: 0.8rem;
     color: var(--muted);
     margin-top: 10px;
    font-style: italic;
	}
	.modal {
	  position: fixed;
	  top: 0; left: 0; right: 0; bottom: 0;
	  background: rgba(0,0,0,0.6);
	  display: none;
	  justify-content: center;
	  align-items: center;
	  z-index: 999;
	}
	.modal.active { display: flex; }

	.modal-card {
	  max-width: 400px;
	  width: 90%;
	  text-align: center;
	}
  </style>
</head>
<body>
  <!-- Level selection -->
  <div id="level-screen" class="screen active">
    <div class="card">
      <h2>Choose level</h2>
      <div class="row">
        <button class="btn" onclick="chooseLevel(1)">Level 1: Vocabulary</button>
        <button class="btn" onclick="chooseLevel(2)">Level 2: Sentences</button>
		<button class="btn" onclick="showReview()">üìñ Review Learned Words</button>
      </div>
      <div class="status">
        <span class="pill" id="net-status">Network: checking‚Ä¶</span>
        <button class="pill" onclick="refreshContent()">Refresh content</button>
      </div>
      <p class="hint">Tip: Contact me if you want me to add other thing.</p>
      <p class="trademark">¬© Made by Adly</p>
    </div>
  </div>

  <!-- Category selection -->
  <div id="category-screen" class="screen">
    <div class="card">
      <h2>Choose category</h2>
      <div class="row">
        <button class="btn" onclick="chooseCategory('foods')">Foods</button>
        <button class="btn" onclick="chooseCategory('activities')">Activities</button>
        <button class="btn" onclick="chooseCategory('places')">Places</button>
        <button class="btn" onclick="chooseCategory('objects')">Objects</button>
		<button class="btn" onclick="chooseCategory('bodyparts')">Body Parts</button>
		<button class="btn" onclick="chooseCategory('vehicles')">Vehicles</button>
        <button class="btn" onclick="chooseCategory('random')">Random mix</button>
      </div>
      <div class="status">
        <span class="pill" id="seed-count">Loaded items: 0</span>
        <span class="pill" id="new-count">New items: 0</span>
      </div>
    </div>
  </div>

  <!-- Quiz -->
  <div id="quiz-screen" class="screen">
    <div class="card">
      <h2 id="quiz-title">Quiz</h2>
      <div id="quiz"></div>
      <div class="status">
        <span class="pill" id="progress">Question 1 / 20</span>
        <span class="pill" id="score-pill">‚úÖ 0 | ‚ùå 0</span>
      </div>
	  <div class="row" style="margin-top:10px;">
		<button class="btn" onclick="confirmBack()">‚¨Ö Back</button>
	  </div>
    </div>
  </div>

  <!-- Round-up -->
  <div id="roundup-screen" class="screen">
    <div class="card">
      <h2>Round up</h2>
      <p id="roundup-summary" style="text-align:center;"></p>
      <div class="row">
        <button class="btn" onclick="continueSame()">Continue same</button>
        <button class="btn" onclick="showScreen('category-screen')">Pick category</button>
        <button class="btn" onclick="showScreen('level-screen')">Pick level</button>
        <button class="btn" onclick="quit()">Quit</button>
      </div>
      <p class="hint">You can refresh content on the Level screen to fetch new words and sentences.</p>
    </div>
  </div>

  <!-- Review Learned Words -->
  <div id="review-screen" class="screen">
    <div class="card">
      <h2>Learned Words</h2>
      <div id="review-list"></div>
      <div class="row">
        <button class="btn" onclick="showScreen('level-screen')">‚¨Ö Back to Levels</button>
      </div>
    </div>
  </div>

  <script>
    const dataSourceUrl = "https://AdlyZed.github.io/QuizArabic/arabic_quiz_data.json";

    // Local seed fallback (works offline) ‚Äî keeps the app running even without internet.
    const seedVocab = {
      foods: [
        { ar:"ÿÆŸèÿ®ÿ≤", en:"Bread", translit:"khubz" },
        { ar:"ŸÑŸéÿ≠ŸÖ", en:"Meat", translit:"la·∏•m" },
        { ar:"ÿ£ÿ±ÿ≤", en:"Rice", translit:" æaruzz" },
        { ar:"ŸÖÿßÿ°", en:"Water", translit:"mƒÅ æ" }
      ],
      activities: [
        { ar:"ŸäŸéŸÇÿ±Ÿéÿ£", en:"Reading", translit:"yaqra æ" },
        { ar:"ŸäŸéÿ≥ÿ®Ÿéÿ≠", en:"Swimming", translit:"yasba·∏•" },
        { ar:"ŸäŸéÿ∂ÿ≠ŸéŸÉ", en:"Laughing", translit:"ya·∏ç·∏•ak" },
        { ar:"ŸäŸéÿ±ŸÉŸèÿ®", en:"Riding", translit:"yarkub" }
      ],
      places: [
        { ar:"ŸÖŸéÿØÿ±Ÿéÿ≥Ÿéÿ©", en:"School", translit:"mad-ra-sa" },
        { ar:"ŸÖŸéÿ≥ÿ¨ŸêÿØ", en:"Mosque", translit:"masjid" },
        { ar:"ÿ≥ŸàŸÇ", en:"Market", translit:"s≈´q" },
        { ar:"ÿ®ŸéŸäÿ™", en:"House", translit:"bayt" }
      ],
      objects: [
        { ar:"ÿ¥ŸéŸÖÿ≥", en:"Sun", translit:"shams" },
        { ar:"ŸÇŸéŸÖÿ±", en:"Moon", translit:"qamar" },
        { ar:"ÿ¥Ÿéÿ¨Ÿéÿ±ÿ©", en:"Tree", translit:"shajara" },
        { ar:"ŸÇŸéŸÑÿ®", en:"Heart", translit:"qalb" }
      ],
	  bodyparts: [
		  { ar:"ÿ±ÿ£ÿ≥", en:"Head", translit:"ra æs" },
		  { ar:"ÿπŸäŸÜ", en:"Eye", translit:" øayn" },
		  { ar:"ÿ£ÿ∞ŸÜ", en:"Ear", translit:"udhun" },
		  { ar:"ÿ£ŸÜŸÅ", en:"Nose", translit:"anf" },
		  { ar:"ŸÅŸÖ", en:"Mouth", translit:"fam" },
		  { ar:"ŸäÿØ", en:"Hand", translit:"yad" },
		  { ar:"ÿ∞ÿ±ÿßÿπ", en:"Arm", translit:"dhirƒÅ ø" },
		  { ar:"ÿ±ÿ¨ŸÑ", en:"Leg", translit:"rijl" },
		  { ar:"ŸÇÿØŸÖ", en:"Foot", translit:"qadam" },
		  { ar:"ŸÇŸÑÿ®", en:"Heart", translit:"qalb" }
	  ],
	  vehicles: [
		  { ar:"ÿ≥ŸéŸäŸëÿßÿ±ÿ©", en:"Car", translit:"sayyƒÅrah" },
		  { ar:"ÿØŸéÿ±Ÿëÿßÿ¨ÿ© ŸÜÿßÿ±ŸäŸëÿ©", en:"Motorcycle", translit:"darrƒÅjah nƒÅriyyah" },
		  { ar:"ÿØŸéÿ±Ÿëÿßÿ¨ÿ©", en:"Bicycle", translit:"darrƒÅjah" },
		  { ar:"ÿ¥ÿßÿ≠ŸêŸÜÿ©", en:"Lorry / Truck", translit:"shƒÅ·∏•inah" },
		  { ar:"ÿπŸéÿ®Ÿëÿßÿ±ÿ©", en:"Ferry", translit:" øabbƒÅrah" },
		  { ar:"ÿ∑ÿßÿ¶Ÿêÿ±ÿ©", en:"Airplane", translit:"·π≠ƒÅ æirah" },
		  { ar:"ŸÖŸêÿ±Ÿàÿ≠ŸäŸëÿ©", en:"Helicopter", translit:"mirwa·∏•iyyah" },
		  { ar:"ŸÇŸêÿ∑ÿßÿ±", en:"Train", translit:"qi·π≠ƒÅr" }
	  ]
    };
    const seedSentences = [
      { ar:"ÿ£ŸÜÿß ÿ£ŸÇÿ±ÿ£ ŸÉÿ™ÿßÿ®Ÿãÿß", en:"I am reading a book", translit:"anƒÅ aqra æ kitƒÅban" },
      { ar:"ŸáŸà Ÿäÿ≥ÿ®ÿ≠ ŸÅŸä ÿßŸÑÿ®ÿ≠ÿ±", en:"He is swimming in the sea", translit:"huwa yasba·∏• fƒ´ al-ba·∏•r" },
      { ar:"ŸÜÿ≠ŸÜ ŸÅŸä ÿßŸÑŸÖÿØÿ±ÿ≥ÿ©", en:"We are at school", translit:"na·∏•nu fƒ´ al-madrasah" },
      { ar:"ŸáŸä ÿ™ÿ£ŸÉŸÑ ÿßŸÑÿÆÿ®ÿ≤", en:"She is eating bread", translit:"hiya ta ækul al-khubz" }
    ];

    // App state
    let netAvailable = false;
    let store = { vocab: seedVocab, sentences: seedSentences }; // merged data
    let currentLevel = 1;
    let currentCategory = null;
    let roundIndex = 0;
    let correct = 0;
    let wrong = 0;
    const roundSize = 20;
    let currentPool = []; // questions for this round

    // Local storage keys
    const LS_CONTENT = "arabic_quiz_content_v1";
    const LS_SEEN = "arabic_quiz_seen_v1";

    // Seen tracking to avoid repeats
    let seenSet = new Set();

    // Init
    window.addEventListener('DOMContentLoaded', async () => {
      // Load cached content
      try {
        const cached = JSON.parse(localStorage.getItem(LS_CONTENT));
        if (cached && cached.vocab && cached.sentences) {
          store = cached;
        }
      } catch {}
      // Load seen
      try {
        const seenArr = JSON.parse(localStorage.getItem(LS_SEEN));
        if (Array.isArray(seenArr)) seenSet = new Set(seenArr);
      } catch {}

      await tryFetchContent();
      updateCounts();
      updateNetStatus();
    });

    async function tryFetchContent() {
      if (!dataSourceUrl) return;
      setNetStatus("Network: loading‚Ä¶");
      try {
        const res = await fetch(dataSourceUrl, { cache: "no-store" });
        if (!res.ok) throw new Error("HTTP " + res.status);
        const json = await res.json();
        // Expected schema:
        // {
        //   "vocab": { "foods":[{ar,en,translit},...], "activities":[...], "places":[...], "objects":[...], "bodyparts":[...], "vehicles":[...] },
        //   "sentences": [{ar,en,translit}, ...]
        // }
        if (json && json.vocab && json.sentences) {
          // Merge: internet items first, then seeds
		  store = {
		    vocab: {
			  foods: mergeUnique(json.vocab.foods || [], seedVocab.foods),
			  activities: mergeUnique(json.vocab.activities || [], seedVocab.activities),
			  places: mergeUnique(json.vocab.places || [], seedVocab.places),
			  objects: mergeUnique(json.vocab.objects || [], seedVocab.objects),
			  bodyparts: mergeUnique(json.vocab.bodyparts || [], seedVocab.bodyparts),
			  vehicles: mergeUnique(json.vocab.vehicles || [], seedVocab.vehicles)
		    },
		    sentences: mergeUnique(json.sentences || [], seedSentences)
		  };
          localStorage.setItem(LS_CONTENT, JSON.stringify(store));
          netAvailable = true;
        } else {
          netAvailable = false;
        }
      } catch (e) {
        netAvailable = false;
      }
    }

    function mergeUnique(primary, fallback) {
      const key = (x) => `${x.ar}::${x.en}`;
      const map = new Map();
      [...primary, ...fallback].forEach(x => {
        if (!x || !x.ar || !x.en) return;
        map.set(key(x), x);
      });
      return Array.from(map.values());
    }

    function refreshContent() {
      tryFetchContent().then(() => {
        updateCounts();
        updateNetStatus();
        alert(netAvailable ? "Content refreshed from internet." : "Could not fetch. Using local data.");
      });
    }

    function updateCounts() {
      const seedCount = (
        store.vocab.foods.length +
        store.vocab.activities.length +
        store.vocab.places.length +
        store.vocab.objects.length +
		store.vocab.bodyparts.length +
		store.vocab.vehicles.length +
        store.sentences.length
      );
      const newCount = seedCount - (
        seedVocab.foods.length +
        seedVocab.activities.length +
        seedVocab.places.length +
        seedVocab.objects.length +
		store.vocab.bodyparts.length +
		store.vocab.vehicles.length +
        seedSentences.length
      );
      document.getElementById("seed-count").textContent = `Loaded items: ${seedCount}`;
      document.getElementById("new-count").textContent = `New items: ${Math.max(0, newCount)}`;
    }

    function setNetStatus(text) {
      document.getElementById("net-status").textContent = text;
    }
    function updateNetStatus() {
      setNetStatus(netAvailable ? "Network: online content loaded" : "Network: offline or no source");
    }

    // Navigation
    function showScreen(id) {
      document.querySelectorAll('.screen').forEach(s => s.classList.remove('active'));
      document.getElementById(id).classList.add('active');
    }
    function chooseLevel(level) {
      currentLevel = level;
      if (level === 1) {
        showScreen('category-screen');
      } else {
        currentCategory = null;
        startRound();
      }
    }
    function chooseCategory(cat) {
      currentCategory = cat;
      startRound();
    }
    function startRound() {
      correct = 0; wrong = 0; roundIndex = 0;
      buildPool();
      document.getElementById("quiz-title").textContent = currentLevel === 1
        ? `Vocabulary ‚Äî ${currentCategory === 'random' ? 'Random mix' : capitalize(currentCategory)}`
        : "Sentences";
      showScreen('quiz-screen');
      renderQuestion();
      updateStatus();
    }

    function buildPool() {
      const pool = [];
      if (currentLevel === 1) {
        let source = [];
        if (currentCategory === 'random' || !currentCategory) {
          source = [
            ...store.vocab.foods.map(x => ({...x, cat:'foods'})),
            ...store.vocab.activities.map(x => ({...x, cat:'activities'})),
            ...store.vocab.places.map(x => ({...x, cat:'places'})),
            ...store.vocab.objects.map(x => ({...x, cat:'objects'})),
			...store.vocab.bodyparts.map(x => ({...x, cat:'bodyparts'})),
			...store.vocab.vehicles.map(x => ({...x, cat:'vehicles'}))
          ];
        } else {
          source = store.vocab[currentCategory].map(x => ({...x, cat: currentCategory}));
        }
        // Prioritize unseen
        const unseen = source.filter(x => !seenSet.has(keyItem(x)));
        const seen = source.filter(x => seenSet.has(keyItem(x)));
        pool.push(...shuffle(unseen), ...shuffle(seen));
      } else {
        const sentences = store.sentences.slice();
        const unseen = sentences.filter(x => !seenSet.has(keyItem(x)));
        const seen = sentences.filter(x => seenSet.has(keyItem(x)));
        pool.push(...shuffle(unseen), ...shuffle(seen));
      }
      // If pool too small, repeat shuffled to reach roundSize
      currentPool = [];
      while (currentPool.length < roundSize) {
        currentPool.push(...shuffle(pool));
        if (pool.length === 0) break;
      }
      currentPool = currentPool.slice(0, roundSize);
    }

function renderQuestion() {
  const q = currentPool[roundIndex];
  if (!q) return;
  const quizDiv = document.getElementById('quiz');
  const direction = Math.random() < 0.5 ? "normal" : "reverse";

  let promptHtml = "";
  let correctText = "";
  let distractors = [];

  if (currentLevel === 1) {
    if (direction === "normal") {
      promptHtml = `<div class="prompt">What does this word mean?</div>
                    <div class="arabic">${q.ar}</div>
                    <div class="translit">Pronounced: <em>${q.translit || ''}</em></div>`;
      correctText = q.en;
      distractors = makeDistractors("en", q.en, q.cat);
    } else {
      promptHtml = `<div class="prompt">Choose the correct Arabic for:</div>
                    <div class="arabic" style="font-size:1.2rem;">${q.en}</div>`;
      correctText = q.ar;
      distractors = makeDistractors("ar", q.ar, q.cat);
    }
  } else {
    if (direction === "normal") {
      promptHtml = `<div class="prompt">What does this sentence mean?</div>
                    <div class="arabic">${q.ar}</div>
                    <div class="translit">Pronounced: <em>${q.translit || ''}</em></div>`;
      correctText = q.en;
      distractors = makeSentenceDistractors("en", q.en);
    } else {
      promptHtml = `<div class="prompt">Choose the correct Arabic sentence for:</div>
                    <div class="arabic" style="font-size:1.2rem;">${q.en}</div>`;
      correctText = q.ar;
      distractors = makeSentenceDistractors("ar", q.ar);
    }
  }

  const options = makeOptions(correctText, distractors);

  quizDiv.innerHTML = `
    ${promptHtml}
    <div class="options" id="options-wrap">
      ${options.map(opt => `<div class="option-card" data-value="${escapeHtml(opt)}">${escapeHtml(opt)}</div>`).join('')}
    </div>
  `;

  // Attach listeners safely
  document.querySelectorAll('#options-wrap .option-card').forEach(card => {
    card.addEventListener('click', () => {
      checkAnswer(card, card.dataset.value, correctText);
    });
  });
}


    function checkAnswer(card, chosenEsc, correctEsc) {
      const chosen = unescapeHtml(chosenEsc);
      const correctText = unescapeHtml(correctEsc);
      const optionsWrap = document.getElementById('options-wrap');
      const cards = Array.from(optionsWrap.querySelectorAll('.option-card'));
      optionsWrap.classList.add('disabled');

      if (chosen === correctText) {
        card.classList.add('correct');
        correct++;
      } else {
        card.classList.add('wrong');
        const correctCard = cards.find(c => c.textContent === correctText);
        if (correctCard) correctCard.classList.add('correct');
        wrong++;
      }

      // Mark seen
      const q = currentPool[roundIndex];
      if (q) {
        seenSet.add(keyItem(q));
        localStorage.setItem(LS_SEEN, JSON.stringify(Array.from(seenSet)));
      }

      setTimeout(() => {
        roundIndex++;
        if (roundIndex >= roundSize) {
          showRoundup();
        } else {
          renderQuestion();
          updateStatus();
        }
      }, 900);
    }

    function updateStatus() {
      document.getElementById("progress").textContent = `Question ${roundIndex + 1} / ${roundSize}`;
      document.getElementById("score-pill").textContent = `‚úÖ ${correct} | ‚ùå ${wrong}`;
    }

    function showRoundup() {
      showScreen('roundup-screen');
      document.getElementById("roundup-summary").textContent = `Correct: ${correct} | Wrong: ${wrong}`;
    }

    function continueSame() {
      startRound();
    }
    function quit() {
      // Simple quit: back to Level screen (you can close the tab manually if needed)
      showScreen('level-screen');
    }
	function showReview() {
	  const listDiv = document.getElementById("review-list");
	  listDiv.innerHTML = "";

	  if (seenSet.size === 0) {
		listDiv.innerHTML = "<p class='hint'>No words learned yet.</p>";
	  } else {
		const items = Array.from(seenSet).map(key => {
		  const [ar, en] = key.split("::");
		  return `<div class="option-card"><b>${ar}</b> ‚Äî ${en}</div>`;
		});
		listDiv.innerHTML = items.join("");
	  }

	  showScreen("review-screen");
	}

	function confirmBack() {
	  document.getElementById("back-modal").classList.add("active");
	}

	function closeBackModal() {
	  document.getElementById("back-modal").classList.remove("active");
	}

	function doBack() {
	  closeBackModal();
	  showScreen('level-screen');
	}

    // Helpers
	function makeOptions(correct, pool, count = 4) {
		const filtered = pool.filter(x => x && x !== correct);
		const picks = shuffle(filtered).slice(0, count - 1);
		const all = [correct, ...picks];
	return shuffle(all);
}

    function shuffle(arr) {
      const a = [...arr];
      for (let i = a.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [a[i], a[j]] = [a[j], a[i]];
      }
      return a;
    }
    function capitalize(s) { return s ? s.charAt(0).toUpperCase() + s.slice(1) : ""; }
    function keyItem(x) { return `${x.ar || ''}::${x.en || ''}`; }

    // Distractors for vocab ‚Äî choose from same category when possible, else cross-category
	function makeDistractors(field, correct, cat) {
	  let source;
	  if (cat === 'random') {
		// Pull from all vocab categories
		source = [
		  ...store.vocab.foods,
		  ...store.vocab.activities,
		  ...store.vocab.places,
		  ...store.vocab.objects,
		  ...store.vocab.bodyparts,
		  ...store.vocab.vehicles
		];
	  } else {
		// Only from the current category
		source = store.vocab[cat] || [];
	  }

	  const pool = source
		.map(x => field === "en" ? x.en : x.ar)
		.filter(v => v && v !== correct);
	  return uniqueSample(pool, 6);
	}
    // Distractors for sentences ‚Äî mix across all sentences, then fallback to simple templates
    function makeSentenceDistractors(field, correct) {
      const base = store.sentences.map(x => field === "en" ? x.en : x.ar).filter(v => v && v !== correct);
      const basePick = uniqueSample(base, 6);
      if (basePick.length >= 3) return basePick.slice(0, 3);
      // Fallback simple templates (avoid duplicate correct)
      const extrasEn = [
        "I am eating bread", "He is running fast", "We are at the market", "She is reading a book"
      ].filter(v => v !== correct);
      const extrasAr = [
        "ÿ£ŸÜÿß ÿ¢ŸÉŸÑ ÿÆÿ®ÿ≤Ÿãÿß", "ŸáŸà Ÿäÿ±ŸÉÿ∂ ÿ®ÿ≥ÿ±ÿπÿ©", "ŸÜÿ≠ŸÜ ŸÅŸä ÿßŸÑÿ≥ŸàŸÇ", "ŸáŸä ÿ™ŸÇÿ±ÿ£ ŸÉÿ™ÿßÿ®Ÿãÿß"
      ].filter(v => v !== correct);
      const extras = field === "en" ? extrasEn : extrasAr;
      return [...basePick, ...uniqueSample(extras, 3 - basePick.length)];
    }
    function uniqueSample(arr, n) {
      const s = shuffle(Array.from(new Set(arr)));
      return s.slice(0, n);
    }

    // Safe HTML for options
    function escapeHtml(str) {
      return String(str)
        .replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;")
        .replace(/"/g, "&quot;").replace(/'/g, "&#039;");
    }
    function unescapeHtml(str) {
      const map = {"&amp;":"&","&lt;":"<","&gt;":">","&quot;":"\"","&#039;":"'"};
      return String(str).replace(/(&amp;|&lt;|&gt;|&quot;|&#039;)/g, s => map[s]);
    }
	if ("serviceWorker" in navigator) {
		navigator.serviceWorker.register("service-worker.js")
		.then(() => console.log("Service Worker registered"))
		.catch(err => console.log("SW registration failed:", err));
	}
  </script>
	  <!-- Back Confirmation Modal -->
		<div id="back-modal" class="modal">
		  <div class="card modal-card">
			<h2>Leave Quiz?</h2>
			<p class="hint">Your current progress will be lost if you go back.</p>
			<div class="row" style="margin-top:10px;">
			  <button class="btn" onclick="closeBackModal()">Cancel</button>
			  <button class="btn" onclick="doBack()">Yes, go back</button>
			</div>
		  </div>
		</div>
	</body>
</html>


